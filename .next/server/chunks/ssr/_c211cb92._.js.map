{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"sources":["file:///C:/projects/wish/src/core/features/Test/test.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const TestComponent = registerClientReference(\n    function() { throw new Error(\"Attempted to call TestComponent() from the server but TestComponent is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/core/features/Test/test.tsx <module evaluation>\",\n    \"TestComponent\",\n);\nexport const setTest = registerClientReference(\n    function() { throw new Error(\"Attempted to call setTest() from the server but setTest is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/core/features/Test/test.tsx <module evaluation>\",\n    \"setTest\",\n);\nexport const testReducer = registerClientReference(\n    function() { throw new Error(\"Attempted to call testReducer() from the server but testReducer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/core/features/Test/test.tsx <module evaluation>\",\n    \"testReducer\",\n);\nexport const testSelector = registerClientReference(\n    function() { throw new Error(\"Attempted to call testSelector() from the server but testSelector is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/core/features/Test/test.tsx <module evaluation>\",\n    \"testSelector\",\n);\nexport const testSlice = registerClientReference(\n    function() { throw new Error(\"Attempted to call testSlice() from the server but testSlice is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/core/features/Test/test.tsx <module evaluation>\",\n    \"testSlice\",\n);\n"],"names":[],"mappings":";;;;;;;AAAA;;AACO,MAAM,gBAAgB,CAAA,GAAA,oXAAA,CAAA,0BAAuB,AAAD,EAC/C;IAAa,MAAM,IAAI,MAAM;AAA0O,GACvQ,iEACA;AAEG,MAAM,UAAU,CAAA,GAAA,oXAAA,CAAA,0BAAuB,AAAD,EACzC;IAAa,MAAM,IAAI,MAAM;AAA8N,GAC3P,iEACA;AAEG,MAAM,cAAc,CAAA,GAAA,oXAAA,CAAA,0BAAuB,AAAD,EAC7C;IAAa,MAAM,IAAI,MAAM;AAAsO,GACnQ,iEACA;AAEG,MAAM,eAAe,CAAA,GAAA,oXAAA,CAAA,0BAAuB,AAAD,EAC9C;IAAa,MAAM,IAAI,MAAM;AAAwO,GACrQ,iEACA;AAEG,MAAM,YAAY,CAAA,GAAA,oXAAA,CAAA,0BAAuB,AAAD,EAC3C;IAAa,MAAM,IAAI,MAAM;AAAkO,GAC/P,iEACA","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///C:/projects/wish/src/core/features/Test/test.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const TestComponent = registerClientReference(\n    function() { throw new Error(\"Attempted to call TestComponent() from the server but TestComponent is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/core/features/Test/test.tsx\",\n    \"TestComponent\",\n);\nexport const setTest = registerClientReference(\n    function() { throw new Error(\"Attempted to call setTest() from the server but setTest is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/core/features/Test/test.tsx\",\n    \"setTest\",\n);\nexport const testReducer = registerClientReference(\n    function() { throw new Error(\"Attempted to call testReducer() from the server but testReducer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/core/features/Test/test.tsx\",\n    \"testReducer\",\n);\nexport const testSelector = registerClientReference(\n    function() { throw new Error(\"Attempted to call testSelector() from the server but testSelector is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/core/features/Test/test.tsx\",\n    \"testSelector\",\n);\nexport const testSlice = registerClientReference(\n    function() { throw new Error(\"Attempted to call testSlice() from the server but testSlice is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/core/features/Test/test.tsx\",\n    \"testSlice\",\n);\n"],"names":[],"mappings":";;;;;;;AAAA;;AACO,MAAM,gBAAgB,CAAA,GAAA,oXAAA,CAAA,0BAAuB,AAAD,EAC/C;IAAa,MAAM,IAAI,MAAM;AAA0O,GACvQ,6CACA;AAEG,MAAM,UAAU,CAAA,GAAA,oXAAA,CAAA,0BAAuB,AAAD,EACzC;IAAa,MAAM,IAAI,MAAM;AAA8N,GAC3P,6CACA;AAEG,MAAM,cAAc,CAAA,GAAA,oXAAA,CAAA,0BAAuB,AAAD,EAC7C;IAAa,MAAM,IAAI,MAAM;AAAsO,GACnQ,6CACA;AAEG,MAAM,eAAe,CAAA,GAAA,oXAAA,CAAA,0BAAuB,AAAD,EAC9C;IAAa,MAAM,IAAI,MAAM;AAAwO,GACrQ,6CACA;AAEG,MAAM,YAAY,CAAA,GAAA,oXAAA,CAAA,0BAAuB,AAAD,EAC3C;IAAa,MAAM,IAAI,MAAM;AAAkO,GAC/P,6CACA","debugId":null}},
    {"offset": {"line": 90, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///C:/projects/wish/src/core/shared/lib/fetchService/fetchService.ts"],"sourcesContent":["export interface RequestConfig {\n    input: RequestInfo | URL;\n    init?: RequestInit | undefined;\n}\n\nexport interface RequestInterceptor {\n    onFulfilled?:\n        | ((config: RequestConfig) => RequestConfig | Promise<RequestConfig>)\n        | undefined;\n    onRejected?: ((error: unknown) => unknown | Promise<unknown>) | undefined;\n}\n\nexport interface ResponseInterceptor {\n    onFulfilled?:\n        | ((\n              response: Response,\n              config: RequestConfig\n          ) => Response | Promise<Response>)\n        | undefined;\n    onRejected?:\n        | ((\n              error: unknown,\n              config: RequestConfig\n          ) => unknown | Promise<unknown>)\n        | undefined;\n}\n\nexport interface FetchClientConfig extends RequestInit {\n    baseURL?: string;\n}\n\nexport interface FetchService {\n    useRequest: (\n        onFulfilled?: (\n            config: RequestConfig\n        ) => RequestConfig | Promise<RequestConfig>,\n        onRejected?: (error: unknown) => unknown | Promise<unknown>\n    ) => void;\n    useResponse: (\n        onFulfilled?: (\n            response: Response,\n            config: RequestConfig\n        ) => Response | Promise<Response>,\n        onRejected?: (\n            error: unknown,\n            config: RequestConfig\n        ) => unknown | Promise<unknown>\n    ) => void;\n    fetch: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;\n}\n\nexport const fetchService = (config: FetchClientConfig): FetchService => {\n    const { baseURL, ...configInit } = config;\n\n    const requestInterceptors: RequestInterceptor[] = [];\n    const responseInterceptors: ResponseInterceptor[] = [];\n\n    const useRequest = (\n        onFulfilled?: (\n            config: RequestConfig\n        ) => RequestConfig | Promise<RequestConfig>,\n        onRejected?: (error: unknown) => unknown | Promise<unknown>\n    ) => {\n        requestInterceptors.push({ onFulfilled, onRejected });\n    };\n\n    const useResponse = (\n        onFulfilled?: (\n            response: Response,\n            config: RequestConfig\n        ) => Response | Promise<Response>,\n        onRejected?: (\n            error: unknown,\n            config: RequestConfig\n        ) => unknown | Promise<unknown>\n    ) => {\n        responseInterceptors.push({ onFulfilled, onRejected });\n    };\n\n    const fetch = async (\n        input: RequestInfo | URL,\n        init?: RequestInit\n    ): Promise<Response> => {\n        const requestInit = init\n            ? {\n                  ...configInit,\n                  ...init,\n                  headers: {\n                      ...configInit?.headers,\n                      ...init?.headers,\n                  },\n              }\n            : configInit;\n\n        const requestConfig = await runRequestInterceptors({\n            input,\n            init: requestInit,\n        });\n\n        let response: Response;\n        try {\n            const requestUrl =\n                baseURL && !input.toString().startsWith('http')\n                    ? `${baseURL}${input}`\n                    : input;\n            response = await globalThis.fetch(requestUrl, requestConfig.init);\n        } catch (error) {\n            return handleFetchError(error, requestConfig);\n        }\n\n        return runResponseInterceptors(response, requestConfig);\n    };\n\n    const runRequestInterceptors = async (\n        config: RequestConfig\n    ): Promise<RequestConfig> => {\n        let currentConfig = config;\n\n        for (const { onFulfilled, onRejected } of requestInterceptors) {\n            currentConfig = await invokeRequestInterceptor(\n                currentConfig,\n                onFulfilled,\n                onRejected\n            );\n        }\n\n        return currentConfig;\n    };\n\n    const invokeRequestInterceptor = async (\n        config: RequestConfig,\n        onFulfilled?: (\n            cfg: RequestConfig\n        ) => RequestConfig | Promise<RequestConfig>,\n        onRejected?: (error: unknown) => unknown | Promise<unknown>\n    ): Promise<RequestConfig> => {\n        try {\n            if (!onFulfilled) {\n                return config;\n            }\n\n            const modified = await onFulfilled(config);\n\n            return modified ?? config;\n        } catch (error) {\n            if (onRejected) {\n                const result = await onRejected(error);\n\n                throw result ?? error;\n            }\n\n            throw error;\n        }\n    };\n\n    const runResponseInterceptors = async (\n        response: Response,\n        config: RequestConfig\n    ): Promise<Response> => {\n        let chainResult = response;\n\n        for (const { onFulfilled, onRejected } of responseInterceptors) {\n            chainResult = await invokeResponseInterceptor(\n                chainResult,\n                config,\n                onFulfilled,\n                onRejected\n            );\n        }\n\n        return chainResult;\n    };\n\n    const invokeResponseInterceptor = async (\n        response: Response,\n        config: RequestConfig,\n        onFulfilled?: (\n            res: Response,\n            config: RequestConfig\n        ) => Response | Promise<Response>,\n        onRejected?: (\n            error: unknown,\n            config: RequestConfig\n        ) => unknown | Promise<unknown>\n    ): Promise<Response> => {\n        try {\n            if (!onFulfilled) {\n                return response;\n            }\n\n            const modified = await onFulfilled(response, config);\n\n            return modified ?? response;\n        } catch (error) {\n            if (onRejected) {\n                const recovered = await onRejected(error, config);\n\n                if (recovered instanceof Response) {\n                    return recovered;\n                }\n\n                throw recovered ?? error;\n            }\n\n            throw error;\n        }\n    };\n\n    const handleFetchError = async (\n        error: unknown,\n        config: RequestConfig\n    ): Promise<Response> => {\n        for (const { onRejected } of responseInterceptors) {\n            if (onRejected) {\n                const recovered = await onRejected(error, config);\n\n                if (recovered instanceof Response) {\n                    return recovered;\n                }\n\n                throw recovered ?? error;\n            }\n        }\n\n        throw error;\n    };\n\n    return {\n        useRequest,\n        useResponse,\n        fetch,\n    };\n};\n"],"names":[],"mappings":";;;AAmDO,MAAM,eAAe,CAAC;IACzB,MAAM,EAAE,OAAO,EAAE,GAAG,YAAY,GAAG;IAEnC,MAAM,sBAA4C,EAAE;IACpD,MAAM,uBAA8C,EAAE;IAEtD,MAAM,aAAa,CACf,aAGA;QAEA,oBAAoB,IAAI,CAAC;YAAE;YAAa;QAAW;IACvD;IAEA,MAAM,cAAc,CAChB,aAIA;QAKA,qBAAqB,IAAI,CAAC;YAAE;YAAa;QAAW;IACxD;IAEA,MAAM,QAAQ,OACV,OACA;QAEA,MAAM,cAAc,OACd;YACI,GAAG,UAAU;YACb,GAAG,IAAI;YACP,SAAS;gBACL,GAAG,YAAY,OAAO;gBACtB,GAAG,MAAM,OAAO;YACpB;QACJ,IACA;QAEN,MAAM,gBAAgB,MAAM,uBAAuB;YAC/C;YACA,MAAM;QACV;QAEA,IAAI;QACJ,IAAI;YACA,MAAM,aACF,WAAW,CAAC,MAAM,QAAQ,GAAG,UAAU,CAAC,UAClC,GAAG,UAAU,OAAO,GACpB;YACV,WAAW,MAAM,WAAW,KAAK,CAAC,YAAY,cAAc,IAAI;QACpE,EAAE,OAAO,OAAO;YACZ,OAAO,iBAAiB,OAAO;QACnC;QAEA,OAAO,wBAAwB,UAAU;IAC7C;IAEA,MAAM,yBAAyB,OAC3B;QAEA,IAAI,gBAAgB;QAEpB,KAAK,MAAM,EAAE,WAAW,EAAE,UAAU,EAAE,IAAI,oBAAqB;YAC3D,gBAAgB,MAAM,yBAClB,eACA,aACA;QAER;QAEA,OAAO;IACX;IAEA,MAAM,2BAA2B,OAC7B,QACA,aAGA;QAEA,IAAI;YACA,IAAI,CAAC,aAAa;gBACd,OAAO;YACX;YAEA,MAAM,WAAW,MAAM,YAAY;YAEnC,OAAO,YAAY;QACvB,EAAE,OAAO,OAAO;YACZ,IAAI,YAAY;gBACZ,MAAM,SAAS,MAAM,WAAW;gBAEhC,MAAM,UAAU;YACpB;YAEA,MAAM;QACV;IACJ;IAEA,MAAM,0BAA0B,OAC5B,UACA;QAEA,IAAI,cAAc;QAElB,KAAK,MAAM,EAAE,WAAW,EAAE,UAAU,EAAE,IAAI,qBAAsB;YAC5D,cAAc,MAAM,0BAChB,aACA,QACA,aACA;QAER;QAEA,OAAO;IACX;IAEA,MAAM,4BAA4B,OAC9B,UACA,QACA,aAIA;QAKA,IAAI;YACA,IAAI,CAAC,aAAa;gBACd,OAAO;YACX;YAEA,MAAM,WAAW,MAAM,YAAY,UAAU;YAE7C,OAAO,YAAY;QACvB,EAAE,OAAO,OAAO;YACZ,IAAI,YAAY;gBACZ,MAAM,YAAY,MAAM,WAAW,OAAO;gBAE1C,IAAI,qBAAqB,UAAU;oBAC/B,OAAO;gBACX;gBAEA,MAAM,aAAa;YACvB;YAEA,MAAM;QACV;IACJ;IAEA,MAAM,mBAAmB,OACrB,OACA;QAEA,KAAK,MAAM,EAAE,UAAU,EAAE,IAAI,qBAAsB;YAC/C,IAAI,YAAY;gBACZ,MAAM,YAAY,MAAM,WAAW,OAAO;gBAE1C,IAAI,qBAAqB,UAAU;oBAC/B,OAAO;gBACX;gBAEA,MAAM,aAAa;YACvB;QACJ;QAEA,MAAM;IACV;IAEA,OAAO;QACH;QACA;QACA;IACJ;AACJ","debugId":null}},
    {"offset": {"line": 212, "column": 0}, "map": {"version":3,"sources":["file:///C:/projects/wish/src/core/shared/api/routes/httpService/consts/index.ts"],"sourcesContent":["export const httpServiceParams = {\r\n    baseURL: 'http://77.223.98.221/',\r\n    headers: {\r\n        'Content-Type': 'application/json',\r\n        Accept: 'application/json',\r\n        'X-Client-Type': 'WEB',\r\n    },\r\n};\r\n"],"names":[],"mappings":";;;AAAO,MAAM,oBAAoB;IAC7B,SAAS;IACT,SAAS;QACL,gBAAgB;QAChB,QAAQ;QACR,iBAAiB;IACrB;AACJ","debugId":null}},
    {"offset": {"line": 229, "column": 0}, "map": {"version":3,"sources":["file:///C:/projects/wish/src/core/shared/api/routes/httpService/server/httpService.ts"],"sourcesContent":["import { fetchService } from '@/core/shared/lib/fetchService/fetchService';\n\nimport { httpServiceParams } from '../consts';\n\nconst httpService = (() => {\n    const service = fetchService(httpServiceParams);\n\n    // TODO: add interceptors\n\n    return service;\n})();\n\nexport { httpService };\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAEA,MAAM,cAAc,CAAC;IACjB,MAAM,UAAU,CAAA,GAAA,4JAAA,CAAA,eAAY,AAAD,EAAE,wKAAA,CAAA,oBAAiB;IAE9C,yBAAyB;IAEzB,OAAO;AACX,CAAC","debugId":null}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"sources":["file:///C:/projects/wish/src/core/pages/index.tsx"],"sourcesContent":["import { httpService } from \"@/core/shared/api/routes/httpService/server/httpService\";\n\nexport const MainPage = async () => {\n    const response = await httpService.fetch('test')\n    console.log(response)\n\n    return <div>Main page</div>;\n};\n"],"names":[],"mappings":";;;;AAAA;;;AAEO,MAAM,WAAW;IACpB,MAAM,WAAW,MAAM,8KAAA,CAAA,cAAW,CAAC,KAAK,CAAC;IACzC,QAAQ,GAAG,CAAC;IAEZ,qBAAO,6WAAC;kBAAI;;;;;;AAChB","debugId":null}},
    {"offset": {"line": 272, "column": 0}, "map": {"version":3,"sources":["file:///C:/projects/wish/src/app/%5Blocale%5D/%28index%29/page.tsx"],"sourcesContent":["import { TestComponent } from '@/core/features/Test/test';\nimport { MainPage } from '@/core/pages';\nimport { getServerTranslation } from '@/core/shared/i18n';\n\nexport async function generateMetadata() {\n    const { t } = await getServerTranslation('meta');\n\n    return {\n        title: t('meta:main.title'),\n        description: t('meta:main.description'),\n    };\n}\n\nexport default async function IndexPage() {\n    return (\n        <main>\n            <MainPage />\n            <TestComponent />\n        </main>\n    );\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;;AAEO,eAAe;IAClB,MAAM,EAAE,CAAC,EAAE,GAAG,MAAM,CAAA,GAAA,sIAAA,CAAA,uBAAoB,AAAD,EAAE;IAEzC,OAAO;QACH,OAAO,EAAE;QACT,aAAa,EAAE;IACnB;AACJ;AAEe,eAAe;IAC1B,qBACI,6WAAC;;0BACG,6WAAC,8HAAA,CAAA,WAAQ;;;;;0BACT,6WAAC,wIAAA,CAAA,gBAAa;;;;;;;;;;;AAG1B","debugId":null}}]
}